{"posts":[{"title":"PCB之路","content":"​ 突发奇想！心血来潮！想从0到1动手做一个板子！小巧又精致的C8T6作为最小系统板，无疑是个不错的选择。继“芯片风波”之后，当前大多数厂商的产品开始相继替换国产的MCU，想着既然做了那就做一个国产MCU的项目吧！ ​ 兆易创新出品的GD32是目前国内32位单片机的主流替换芯，经了解，GD32F103C8T6的封装与STM32F103C8T6一致，只是芯片主频和Flash等规格上有所不同，物理层面的引脚是完全一致的，可直接替换。 ​ 网上对GD32F103C8T6的原理图资料较少，嘉立创EDA开源硬件社区上有不少关于STM32F103C8T6的原理图绘制，本着先模仿、再成为、而后超越的想法，参考了多位前辈画的STM32F103C8T6以及部分GD32其他芯片的原理图，最后决定绘制GD32F103C8T6。 ​ 参考项目： 2024-5-10-STM32F103最小系统板 - 嘉立创EDA开源硬件平台 (oshwhub.com) STM32最小系统板-Type-C和MicroUSB版本 - 嘉立创EDA开源硬件平台 (oshwhub.com) stm32f103c8t6最小系统板 - 嘉立创EDA开源硬件平台 (oshwhub.com) STM32F103C8T6最小系统板 - 嘉立创EDA开源硬件平台 (oshwhub.com) 立创·GD32E230最小系统板 - 嘉立创EDA开源硬件平台 (oshwhub.com) ​ GD32F103C8T6 原理图： ​ GD32F103C8T6 PCB Layout： ​ GD32F103C8T6 预览图： ​ 在此之前，4月份时接触过一点PCB绘制，当时在做毕设，看着我的主控和传感器直接连接了一堆的杜邦线，很是难看，有没有什么方法可以摒弃大量的杜邦线让系统看起来更简洁呢？考虑过用面包板和短线连接，虽然不会耷拉着一堆传感器，但本质还是杜邦线。于是萌生了做个PCB集成一下电路的想法，便开始了原理图首次绘制。 ​ 智慧花园项目板原理图： ​ 智慧花园项目板 PCB Layout： ​ 智慧花园项目板预览图： ","link":"https://Arron795.github.io/post/LCPCB/"},{"title":" T113-Pro的buildroot添加gdisk ( GPT disks )出现***gptfdisk needs a toolchain w/ C++***的解决方法","content":"问题背景： ​ 最近入手了百问网的全志T113-Pro，用Emmc启动发现一张32GB的SD卡在烧录了百问网镜像 100ask-t113-pro_sdcard.img 的系统后，仅有200多M的存储空间。第一时间上百问网论坛看是否有板友也出现类似情况，发现了一个帖子正是描述这种情况的。 百问网论坛相关帖子地址：文件系统打包烧写到sd卡，没有完全利用sd卡的全部空间 - Allwinner / T113_PRO - 嵌入式开发问答社区 (100ask.net) *（这里做一个说明，百问网对全志T113-Pro给了两个镜像，一个是含lvgl的 100ask-t113-pro-lvgl_sdcard.img ，有屏幕的话可以看到开机自启动的lvgl画面，并且可以在/etc/init.d里找到S50lvgl-desktop可执行程序；一个是不含lvgl的 100ask-t113-pro_sdcard.img ，这两个在空间上相差仅有20多M，前者多70M，后者50多M，注意甄别。） 后来查T113-Pro相关资料，在CSDN意外发现正好有解决该问题的文章。跟着板友学习了一下，在buildroot添加gdisk过程中遇到了一些问题，这里做一个补充，方便后来的板友参考。 CSDN文章地址：【全志T113-S3_100ask】SD卡扩容_系统烧录在sd卡中后怎么扩容-CSDN博客 buildroot添加gdisk ( GPT disks )步骤可能会遇到的问题： gptfdisk无法勾选，显示*** gptfdisk needs a toolchain w/ C++ *** 解决方法： 在buildroot目录下输入make menuconfig 进入配置模式，选中Toolchain ---&gt; 回车进入。 确认一下编译用的C库用的是哪个库。 一般选择uClibc-ng和glibc任意一个即可。（回车选择） 回车后自动回到Toolchain，往下找到Enable C++ support，按Y勾选，保存退出。 随后即可在 Target packages ---&gt; ​ Hardware handling ---&gt; 下选择是否勾选gptfdisk，按Y勾选，保存退出。 ","link":"https://Arron795.github.io/post/t113pro-buildroot-gdisk/"},{"title":"以STM32F103C8T6为主控实现的RFID感应宿舍门锁开关","content":"为什么做这个东西？ ​ 上个月月末闲来无事上bilibili搜索物联网相关的设计，偶然间看到一个用C8T6 + RFID感应模块 + 舵机实现的小玩意，具体过程是IC卡或者手机NFC区（需复制IC卡后）贴近RFID感应区，C8T6检测到有卡靠近，控制舵机旋转，通过绳索拉动门把手，实现刷卡（手机）入室。觉得这小玩意挺有意思的，并且舍友有时会忘记带钥匙，再加上正好当复习STM32开发流程了，看看能否温故而知新。 需求分析： ​ 由于该项目用到的外设并没有很多，芯片性能需求不大，所以主控选择的是STM32C8T6F103最小系统板； ​ 项目需要能检测IC卡，感应模块选择网上随便都能买到的 RFID-RC522 ； ​ 项目需要能开门，拉动门把手是最容易的开门方式，舵机拉动是不错的选择，常见的SG90即可。 ​ 一般来说，拥有以上三种物料即可简单实现。但是为了更加人性化和合理化，我另外添加了两种物料： 一个是蜂鸣器， 用于系统检测到IC卡开门时触发声响，方便用户知道当前系统是否成功检测到IC卡并开门，避免无效刷卡进门失败和错过有效进门时机。当检测到正确卡号，响鸣0.5s；当检测到错误卡号，则间隔响鸣0.01秒，直至移开IC卡响鸣停止。 一个是按键，用于触发中断，唤醒芯片。 ​ 为什么要唤醒？因为设计之初是打算用移动电源供电，考虑到系统需要长时间供电，如果让单片机长时间无休止地运行，耗电是必然的。（即使比起电脑电视等设备，单片机耗的这点电不算什么，但毕竟是嵌入式，低功耗是嵌入式的特点） ​ 而用户有开门需求的时机并不是长期的，单片机运作时大多数时间都是在等待用户刷卡，真正有效的运作仅有在需要开门的那几秒，那么这样看来，单片机长时间的耗电运作等待用户的到来似乎没有必要。为了避免让单片机长时间的耗电等待，是否有一种方案能让单片机在等待用户到来这段时间里是处于休眠停止的状态，等用户到来了，再唤醒工作呢？我在 STM32F103x8B 的 datasheet 里找到了答案。STM32F103C8T6 芯片设计了三种低功耗模式（详见 STM32F103x8 数据手册 “2.3.12 低功耗模式” ），睡眠模式是其中一种解决思路。 解决方案： ​ datasheet中提到，进入低功耗模式的芯片，可用中断唤醒。于是我的想法是让系统进入睡眠模式，用一个按键作为外部中断EXTI，当用户到来，按下按键触发中断，唤醒系统。此时系统检测是否有卡贴近，当有，驱动舵机开门；当无，在一段循环等待后再次进入睡眠模式。 物料选型： ​ 主控：STM32F103C8T6 ​ 感应模块：RFID-RC522 ​ 舵机：SG90 ​ *有源蜂鸣器：用于开门时作提示音 ​ *按键：从鼠标按键上拆下来的小按键 杜邦线若干：公对母或者母对母，根据自己需求选择 电源： ​ 电源方案有两种，任选其一即可。考虑到用移动电源会有电源用完，需要拆下电源给其充电的情况，加之对移动电源也是一种损耗，我最终选择的是方案一。 方案一： 5V 1A USB充电头 1个； 5米USB 3.0 公母延长线 1条 （*必须要3.0，2.0不行，尽量挑导线材质好一些的，导线材质差有可能经过长距离的传输，电压到达末端时会有电压损耗，具体长度需求根据实际情况购买）； MicroUSB 充电线 1条； 方案二： 移动电源 1个； MicroUSB 充电线 1条； 这里对电源方案的选择做一个分析，仅供参考。 ​ 根据 STM32F103x8 的数据手册第 5.3.5 节 供电电流特性 提到，在 最大电流消耗 的运行模式下，使能所有外部时钟，72MHz（最大频率），85℃ 的情况下，电流消耗在50mA。而关闭所有外设后，仅在32.8mA。 ​ 在睡眠模式下，使能所有外部时钟，72MHz（最大频率），85℃ 的情况下，电流消耗在30mh。关闭所有外设后，仅有7.5mA。 从上述两图总结得出，在其他条件同等，睡眠模式下可有效降低耗电，若同时关闭不必的外设，可以更进一步地降低耗电。 ​ 在 典型电流消耗 的运行模式，使能所有外设，85℃，72MHz的情况下，电流消耗在40mA上下。 ​ 在 典型电流消耗 的运行模式，关闭所有外设，85℃，72MHz的情况下，电流消耗在25mA上下。 ​ 假设系统以最大功耗运行（运行模式下，使能所有外部时钟，72MHz），此时50mA的电流消耗，供电电压3.6V，那么一个小时会消耗0.18度电。一个5000mA的移动电源可供其约138个小时。 电能（kWh）=0.05A×3.6V×1h=0.18kWh电能（kWh）=0.05A×3.6V×1h=0.18kWh 电能（kWh）=0.05A×3.6V×1h=0.18kWh ​ 再假设系统以睡眠模式下，72MHz，供电电压3.6V，此时电流消耗在7.5mA ~ 30mA之间（关闭所有外设 和 使能所有外设），系统用到的外设功能并不多，仅有一个SPI、一个PWM以及若干GPIO，大胆估设电流消耗为15mA，那么一个小时仅消耗0.054度电。一个5000mA的移动电源可供其462个小时左右，有效地降低了电耗。 电能（kWh）=0.015A×3.6V×1h=0.054kWh电能（kWh）=0.015A×3.6V×1h=0.054kWh 电能（kWh）=0.015A×3.6V×1h=0.054kWh 硬件连接图： ​ *因实际部署时，板上的3.3V和GND口不足，且蜂鸣器位置较为特殊，故把蜂鸣器接在SWD调试口的源地接口。实际操作可根据自己的需求灵活接线。 实物图： 部署效果： 代码链接🔗：https://github.com/Arron795/DormLock ","link":"https://Arron795.github.io/post/dormlock/"},{"title":"虚拟机如何在主机可以访问外网的情况下也访问外网","content":"为什么写这篇文章？ ​ 最近在学习Raspberry Pi Pico的相关内容，Pico是支持MicroPython SDK和 C++ SDK 的。用MicroPython官方推荐的IDE是Thonny，但我用它写代码觉得很难受，智能提示和补全用起来不是很顺手。我在想要不用VS code + 拓展试试？还真在网上找到了相关的文章，用的是VS code + Python + MicroPico拓展。 ​ 在查找相关文章之时，发现了一篇用Raspberry Pi Pico官方C++ SDK + Linux + cmake 的环境配置教程，开发方式是 Windows下用 VS code 写代码，远程连接Ubuntu虚拟机，在虚拟机下用 gcc 编译 + make构建生成.uf2文件，再将.uf2文件传输到Windows主机并拖拽至RPI-RP2存储设备（即Pico板）实现开发。 ​ 教程链接：轻松玩转树莓派Pico一、树莓派pico新手上路 - 知乎 (zhihu.com) ​ 在Ubuntu用 git 克隆Raspberry Pi官方的Pico SDK时要么特别慢要么会显示拒绝连接，加之有时克隆的项目会出现部分文件缺失。个人猜测是在国内访问GitHub站点不稳定所致。 ​ 对个人而言，最好的解决办法就是挂VPN。我在Windows下用的是Clash for windows，最简单的方式就是在Ubuntu也下一个Clash。个人认为，这也是一种解决方式，但一定不是最合理的。那有没有一种方法，让**Windows主机用Clash能够访问外网的同时，让虚拟机也能访问到外网呢？**答案是肯定的。 解决方法： ​ 在和ChatGPT“磨合”了一会后，摸索出了一套方案。首先，你得具有一些必要的软件或环境。 主机系统：Windows 11 代理软件：Clash for windows 虚拟机软件：VM wave 14 虚拟机系统：Ubuntu 18.04 LTS（Linux） 打开VM wave 点击编辑 → 虚拟机网络编辑器。 点击右下角的更改设置，需要用管理员身份运行。 添加一个网络，选择桥接模式，我电脑和路由器是无线连接的，所以选择Wi-Fi驱动设备，若是用网线连接，选择相应的驱动设备即可。修改完成后，先点击应用，再点击确定。 在Windows下按 Win + R 输入cmd或者powershell，点击确定。 在命令行输入ipconfig，查看Windows本地IP。 登录Ubuntu系统，在命令行输入ifconfig查看本地IP地址，并尝试Ping主机。 主机和虚拟机相互Ping通是必须的。 在命令行输入gedit .bashrc（若没有安装gedit工具，则用 vi .bashrc 或 vim .bashrc）。 sudo gedit .bashrc 在 .bashrc 文件中添加以下两行。 export http_proxy=http://Windows主机IP:Clash代理端口 export https_proxy=http://Windows主机IP:Clash代理端口 IP是用Windows主机的IP，端口号可以在Clash查看。 编辑完 .bashrc 后，Ctrl + S 保存退出。（必要的话可以尝试重启系统，用命令reboot即可重启） 勾选Clash中的必要选项。（Clash for Windows的使用我不在这里赘述，详细使用教程可上网搜索查得。） Allow LAN选项是允许同一网段下的网络绑定，此前我已将 Windows 主机和 Ubuntu 虚拟机已经配置到了同一网段下；System Proxy是开启代理。 至此，你的虚拟机便可与主机通过桥接模式访问外网。访问外网和在Github拉取文件更加稳定。 虚拟机下访问YouTube： ","link":"https://Arron795.github.io/post/clash/"},{"title":"关于如何将Android手机中PSP游戏运行在PC端","content":"有一款软件叫悟饭游戏厅，它是一款专门将各类安卓、PSP、GBA游戏资源进行归类的软件。玩家想玩任何一种可以运行在PSP、GBA等掌机或是Android手机上的经典游戏，只需要在该软件上搜索并下载安装即可。 最近在手机上安装了《侠盗猎车：自由城的故事》（Android版），手机操作并没有很方便，且屏幕较小，游戏体验一般。鉴于之前移植过《罪恶都市传奇》（PSP版），于是尝试着将《自由城的故事》也移植到电脑上。 一、获取游戏的镜像文件 下载并安装《悟饭游戏厅》。 将Android手机用数据线连接至PC端，并选择文件传输。（记得打开USB调试模式，可在开发者模式中设置） 在PC端打开我的电脑，进入路径 “D:/此电脑/your phone's name/内部存储设备/Android\\data” 找到一个文件夹名为：“com.join.android.app.mgsim.wufun”。 该目录下有两个子目录，一个是“cache”，为空；另一个是“files”。 进入files，找到“wufan91”文件夹，进入。 可以看到，这里有三个命名为数字的文件夹，其中“34”即为《侠盗猎车：自由城的故事》的文件存放位置。（笔者猜测，应是悟饭游戏厅为每个游戏都设定了一个编号） 继续进入到34下的/roms/xdlczycdgs 此时的路径是：&quot;D:\\此电脑\\your phone's name\\内部存储设备\\com.join.android.app.mgsim.wufun\\files\\wufan91\\34\\roms\\xdlczycdgs&quot;。 在此路径下，可以看到一个存储大小为812MB的sdlczycdgs.iso的映像文件。这个文件便是《侠盗猎车：自由城的故事》的安装文件了。将其拷贝至PC端你想存放的路径。 二、下载PSP模拟器PPSSPP PPSSPP模拟器官网：https://www.ppsspp.org/download/ 进入PPSSPP模拟器官网：Downloads | PPSSPP，根据你的PC和个人喜好选择对应的安装包，笔者是Windows11系统，选择的是Windows的ZIP文件，如下图。 下载并解压到你想存放的路径下，完成后，可看到“ppsspp_win”文件夹，进入，选择PPSSPPWindows.exe或者PPSSPPWindows64.exe任意一个打开，笔者一般选择用64的打开。 打开后会看到如下界面： 若打开后显示全屏，可通过按键盘F11键进行全屏切换，也可以在右边的“游戏设置——图像设置——全屏幕”进行勾选。 三、在PSP模拟器中选择游戏的.iso镜像文件 在PPSSPP界面下，选择载入新游戏，进入到你PC端存放游戏.iso镜像文件的路径下，可以看到如下的游戏图标，点击进入即可进行游戏。 四、其他 1、关于PSP游戏运行在PC的PSP模拟器上，没有手柄该如何用操作游戏呢？ 进入游戏设置——控制设置——按键映射，可以通过键盘按键映射PSP的游戏按键进行设置。 2、在PC端进行游戏存档，想在手机上载入存档继续游戏，该如何操作？ 可在PC端进入你解压PSP模拟器的路径，找到memstick目录（记忆棒存储），进入PSP下的SAVEDATA目录，这个是游戏存档存放的目录，可以看到ULJM05255S0（每个游戏的存档文件目录命名不同），完整路径如下：D:\\Desktop\\ppsspp_win\\memstick\\PSP\\SAVEDATA\\ULJM05255S0 在此目录下，找到DATA.BIN文件和PARAM.SFO文件，将其替换到你的手机对应游戏的存档目录下，如： “D:\\此电脑\\your phone's name\\内部存储设备\\Android\\data\\com.join.android.app.mgsim.wufun\\files\\PSP\\SAVEDATA\\ULJM05255S0” （这里解释一下为什么下图的游戏存档目录是ULJM05297S92F0，上面的是ULJM05255S0，因为笔者截下面的图的时候进错目录了，这是《罪恶都市传奇》的存档目录，然而编辑到此处已经拔了数据线了...当然这无关紧要，只要进入同款游戏对应的目录即可。） 至此即可完成游戏存档在PC和手机之间的转移。 ","link":"https://Arron795.github.io/post/psp/"},{"title":"我的第一篇记录。","content":"今天是2023.9.28，中秋节前夕，在大家都开始准备启程回家的日子里，我记录下了我的第一篇blog。 这是我第一次搭建自己的静态网站，在暑期见过我哥的个人网站后，搭建一个属于我自己的网站这个想法便发出萌芽，但一直都没有很心血来潮。再次迸发出这种欲望是上周在做ESP32-Cam连接阿里云物联网平台时，偶然找到一位名叫巧遇的blog，在这位前辈的最后一个blog里出现了Gridea的字样，怀揣走过路过不放过的好奇心理，进入了Gridea的数字花园，于是便有了你现在所看到的这篇文章。 没有什么图好放，那就简单插入两张晚餐叭。🙂（听说吃波叔面家的人都很会幸运~） ","link":"https://Arron795.github.io/post/firstblog/"},{"title":"Thread 2 “ThreadPool.out“ received signal SIGSEGV, Segmentation fault.关于空指针解引用引起的段错误异常","content":"问题背景 ​ 最近在学习Linux的多线程和线程池，在调试用C写的一段线程池代码的过程中，出现了一个错误（只截了关键部分）： Thread 2 &quot;ThreadPool.out&quot; received signal SIGSEGV, Segmentation fault. [Switching to Thread 0x7ffff77c2700 (LWP 4298)] 0x00005555555555fa in manager (arg=0x0) at /home/syl/projects/ThreadPool/threadpool.c:246 246 while (!pool-&gt;shutdown) Segmentation fault 大意是说在246行的while (!pool-&gt;shutdown)处出现了段错误。（图中是修改过的所以显示250，可忽略） 这里说明一下246行附近写了什么： void* manager(void* arg) { ThreadPool* pool = (ThreadPool*)arg; while (!pool-&gt;shutdown) // 246行处 { ... } return NULL; } 首先来了解一下什么是段错误。（懂的可以略过） 段错误（Segmentation Fault），通常简称为&quot;segfault&quot;，是指当程序访问了一个无效的内存地址或者试图对只读内存进行写操作时，操作系统会终止程序的执行并抛出段错误异常。 段错误通常是由以下情况引起的： 1. 空指针解引用：当程序试图对空指针进行解引用操作，即访问空指针指向的内存地址时，会导致段错误。 2. 访问越界：当程序访问了超出分配给它的内存范围的地址或数组的越界索引时，会导致段错误。 3. 写入只读内存：当程序试图向只读内存地址写入数据时，如字符串常量，会导致段错误。 4. 栈溢出：当程序的栈空间超过了系统所允许的最大限制，会导致栈溢出，进而产生段错误。 段错误的发生会导致程序崩溃，可能会导致进程异常终止。它是一种严重的错误，常常表示程序中存在错误的内存访问行为，如指针错误、内存越界等。调试和修复段错误通常需要定位错误发生的位置，并检查程序中的内存操作、指针使用等问题。使用调试工具（如GDB）和良好的编程实践可以帮助发现和修复段错误。 问题解决 经过和原创者的源代码反复对比，发现线程池创建函数 threadPoolCreate，其中创建线程那里有个函数是： pthread_create (&amp;pool-&gt;managerID, NULL, manager, pool); 注意pthread_create这个函数的第四个参数是 pool 而我的代码中写的是： pthread_create (&amp;pool-&gt;managerID, NULL, manager, NULL); 到这里问题的原因就很明显了，我错把第四个参数写成了NULL，这导致了将一个空指针NULL作为参数arg传递给了manager。这相当于245行的 ThreadPool* pool = (ThreadPool*)arg; 将一个空指针赋给了pool，这样在判断while(!pool-&gt;shutdown)时，当然会出错啦！ 出错的原因也很明显，导致段错误的原因是 pool 变量为 NULL 或未初始化，在尝试访问 pool-&gt;shutdown 时会导致无效的内存访问。（空指针解引用引起的段错误） 最后修改完之后重新调试，编译成功！ 感谢 感谢线程池作者爱编程的大丙提供的学习资源。🙂 ","link":"https://Arron795.github.io/post/threadPoolNullptr/"},{"title":" IMX6ULL编译led驱动程序出现fatal error: generated/autoconf.h以及 ERROR: Kernel configuration is invalid.的解决方法","content":"问题背景 ​ 最近在学习IMX6ULL的驱动程序，在用make命令执行编译led驱动程序时，出现以下报错： make -C /home/book/100ask_imx6ull-sdk/Linux-4.9.88 M=pwd modules make[1]: 进入目录“/home/book/100ask_imx6ull-sdk/Linux-4.9.88” ERROR: Kernel configuration is invalid. include/generated/autoconf.h or include/config/auto.conf are missing. Run 'make oldconfig &amp;&amp; make prepare' on kernel src to fix it. WARNING: Symbol version dump ./Module.symvers is missing; modules will have no dependencies and modversions. CC [M] /home/book/01_all_series_quickstart/05_嵌入式Linux驱动开发基础知识/source/02_led_drv/00_led_drv_simple/imx6ull/led_drv.o In file included from :0:0: ././include/linux/kconfig.h:4:10: fatal error: generated/autoconf.h: 没有那个文件或目录 #include &lt;generated/autoconf.h&gt; ^~~~~~~~~~~~~~~~~~~~~~ compilation terminated. scripts/Makefile.build:299: recipe for target '/home/book/01_all_series_quickstart/05_嵌入式Linux驱动开发基础知识/source/02_led_drv/00_led_drv_simple/imx6ull/led_drv.o' failed make[2]: *** [/home/book/01_all_series_quickstart/05_嵌入式Linux驱动开发基础知识/source/02_led_drv/00_led_drv_simple/imx6ull/led_drv.o] Error 1 Makefile:1499: recipe for target 'module/home/book/01_all_series_quickstart/05_嵌入式Linux驱动开发基础知识/source/02_led_drv/00_led_drv_simple/imx6ull' failed make[1]: *** [module/home/book/01_all_series_quickstart/05_嵌入式Linux驱动开发基础知识/source/02_led_drv/00_led_drv_simple/imx6ull] Error 2 make[1]: 离开目录“/home/book/100ask_imx6ull-sdk/Linux-4.9.88” Makefile:13: recipe for target 'all' failed make: *** [all] Error 2 很明显，上面出现了两个错误和一个警告： 错误1： ERROR: Kernel configuration is invalid. include/generated/autoconf.h or include/config/auto.conf are missing. Run 'make oldconfig &amp;&amp; make prepare' on kernel src to fix it. 大意是说内核配置无效。缺少include/generated/autoconf.h或include/config/auto.conf文件。 需要特别注意的是，这里报错提示给出了解决建议：在内核源码的目录下运行make oldconfig &amp;&amp; make prepare来修复该报错。 错误2： ././include/linux/kconfig.h:4:10: fatal error: generated/autoconf.h: 没有那个文件或目录 #include &lt;generated/autoconf.h&gt; ^~~~~~~~~~~~~~~~~~~~~~ 意思是说，././include/linux/kconfig.h里没有链接generated/autoconf.h文件。 警告： WARNING: Symbol version dump ./Module.symvers is missing; modules will have no dependencies and modversions. 大意是说，Linux内核代码的目录下丢失了符号版本信息文件 Module.symvers文件，将会导致模块没有依赖项和版本信息。 解决过程 ​ 首要考虑是按报错的建议操作去解决，但是到了Linux的源码目录下执行了make oldconfig，但是它会出现许多需要配置的问答，即使我长按空格按默认答案回答，依然需要很长的时间，在长按了一会儿后，直接Ctrl + C放弃了这个建议。几经周折后，终于找到了一个可行的解决方法。 解决方法 1.首先进入内核源代码目录，执行以下命令： make mrproper ​ 这个命令会清除先前的编译结果和配置文件。 2.配置内核编译选项和模块，例如执行以下命令： make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 100ask_imx6ull_defconfig ​ 其中，100ask_imx6ull_defconfig是我使用的硬件平台对应的配置文件。如使用其他配置文件，需要根据实际情况修改。 3.生成Makefile文件，例如执行以下命令： make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig ​ make menuconfig这个命令会打开一个文本界面的配置工具，可以在里面配置内核编译选项和模块。配置完成后，保存退出即可。 ​ 具体操作为 ​ （1）、用方向键移动光标至Enalble loadable module support，确保下面的光标在Select处，回车。保证前方的中括号内有*星号。 （ 2）、用方向键左右移动下面的光标至Save处，回车。 ​ （3）、此页面默认OK，直接回车即可。 ​ （4）、选中Exit，退出menuconfig ​ 4. 运行 'make oldconfig &amp;&amp; make prepare' 命令来修复内核配置，执行以下命令： make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- oldconfig make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- prepare ​ ​ 5.重新编译内核模块，例如执行以下命令： make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules -j4 ​ ​ 6.如果还有模块依赖于 Module.symvers 文件，则需要先编译内核，例如执行以下命令： make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage -j4 make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules -j4 注意，在执行make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage -j4命令时，可能会提示： LZO arch/arm/boot/compressed/piggy_data /bin/sh: 1: lzop: not found arch/arm/boot/compressed/Makefile:186: recipe for target 'arch/arm/boot/compressed/piggy_data' failed 这是没有安装lzop软件包的缘故，只要执行 sudo apt-get update sudo apt-get install lzop 然后再次执行make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage -j4即可。 ","link":"https://Arron795.github.io/post/ledDrive/"},{"title":"Qt中将quint16转换为QByteArray的方法","content":"问题背景 ​ 今天在改进用Qt写的TCP服务器和客户端代码时，想将服务器tcpServer的端口号作为数据发送给客户端，并且需要转为Utf8格式。遇到一个问题，调用TcpSocket中的write(const QByteArray &amp;data)方法，write方法的参数列表中需要填入的参数类型是QByteArray，但tcpServer的serverPort()是一个quint16类型。 问了一下chatGPT，给出的方案是，先将quint转为QTextCodec再转为QByteArray。但我使用的Qt版本是Qt6，已经弃用了QTextCodec。 问题思考和解决方法 ​ 需要解决上述问题，那么就需要将quint16转为QByteArray类型，想法是：首先调用QString的number(int num)方法，将quint16转为QSting，再调用QByteArray的toUtf8()将QString转为QByteArray。 具体代码： quint16 input = this-&gt;tcpServer-&gt;serverPort(); QString str = QString::number(input); //一定要用number转化 不然乱码 QByteArray bytes = str.toUtf8(); 上述代码为了写成一行放在tcpSocket的write方法的参数列表里，改成 QByteArray(QString::number(this-&gt;tcpServer-&gt;serverPort()).toUtf8()) 具体为： tmpTcpSocket-&gt;write(QByteArray(QString::number(this-&gt;tcpServer-&gt;serverPort()).toUtf8()) + &quot; : &quot; + ui.sendEdit-&gt;text().toUtf8()); ","link":"https://Arron795.github.io/post/qtStringExchanged/"},{"title":"ubuntu18.04意外重启后出现GNU GRUB version 2.02的解决方法","content":" 该解决方案仅供参考，不保证所有设备都能解决 问题背景： 通过Windows11使用VM Wave软件开启Ubuntu18.04虚拟机，在设置虚拟网络编辑器和网络适配器连接时，主机意外蓝屏（我电脑老毛病了每次都这样，用的电脑是联想小新13pro 2020版）。 问题描述： 重启主机后，照旧打开虚拟机，发现进不去图形界面，显示一个标题GNU GRUB version 2.02的界面。 解决方案： 接下来需要进入Ubuntu的恢复模式，可以按照以下步骤操作： 在计算机启动时，按住Shift键（我的虚拟机不用按，看具体情况），直到出现Grub引导菜单。 在Grub菜单中选择“Advanced options for Ubuntu”或“高级选项”，然后选择Ubuntu内核版本后面的“recovery mode”或“恢复模式”选项。 如果需要，输入用户名和密码，进入恢复模式的终端。 在恢复模式中，可以进行一些常见的系统维护操作，如文件系统检查和修复、网络设置、密码重置等。具体的操作步骤和选项可能因Ubuntu版本和配置而异，建议在操作前仔细阅读提示信息和文档。 然后会进入一个界面显示： 1.520391] piix4_smbus 0000:00:07.3: SMBUS Host Controller not enabled!2.123455] sd 32:0:0:0: [sda] Assuming drive cache: write throughdev/sda1 contains a file system with errors, check forced.dev/sda1:Entry 'job.cache'in /var/cache/cups (538460) has an incorrect filetype (was 1,should be 2). dev/sda1: UNEXPECTED INCONSISTENCY; RUN fSCK MANUALLY.(i.e.,without -a or -p options)fsck exited with status code 4The root filesystem on /dev/sdal requires a manual fsck BusyBox y1.27.2 (Ubuntu 1:1.27.2-2ubuntu3.2) built-in shell (ash)nter help for a list of built-in commands. （initramfs) 此图用软件翻译过 所以是中文，原文是英文。 这段提示信息表明/dev/sda1分区中的文件系统出现了一些错误，需要进行fsck检查和修复。下面是解决问题的步骤： 在命令提示符（initramfs）下输入“fsck /dev/sda1”命令，对/dev/sda1分区进行检查和修复。如果提示需要输入“y”或“yes”确认，则输入确认。 如果fsck检查和修复过程无法自动解决问题，可以尝试使用“fsck /dev/sda1 -y”命令，使用自动模式进行检查和修复。但需要注意的是，自动模式可能会删除部分数据或文件，因此需要谨慎操作。 如果上述方法仍无法解决问题，可以尝试使用Ubuntu安装盘或Live CD/USB启动计算机，并进入恢复模式。 在恢复模式中，选择“fsck”或“修复文件系统”等选项，进行文件系统的检查和修复。这个过程可能需要一些时间，需要耐心等待。 如果文件系统检查和修复无法解决问题，可以尝试重新安装Ubuntu系统，或者使用备份数据恢复系统。 总之，需要根据具体情况采取相应的解决方案。在进行fsck检查和修复时，需要谨慎操作，避免误删数据或文件。建议在操作前备份重要数据。 ​ 输入完fsck /dev/sda1后显示： /dev/sda1: ***** FILE SYSTEM WAS MODIFIED ***** dev/sda1: 183614/1441792 files (0.1% non-contiguous)，2449716/5766656 blocks (initramfs) ​ 出现“FILE SYSTEM WAS MODIFIED”，说明文件系统已经进行了修复。此时，可以尝试重新启动计算机，看看是否能够正常进入Ubuntu系统。如果能够正常进入系统，建议进行一些常规的系统维护操作，如清理无用文件、更新软件包等，避免类似问题再次出现。 如果重新启动后仍然出现问题，可以尝试进入恢复模式，进行进一步的排查和修复。在恢复模式中，可以进行文件系统的检查和修复、网络设置、密码重置等操作，具体的操作步骤和选项可能因Ubuntu版本和配置而异，建议在操作前仔细阅读提示信息和文档。 总之，在进行任何操作前，需要备份重要数据，以避免数据丢失。 此时，只要再输入reboot重启命令进行重启，再次进入GNU GRUB version 2.02界面选择Ubuntu，回车即可。 到此，ubuntu已经能正常启动并看到图形界面了，问题解决。 再次声明，本解决方案仅供参考，不保证能解决所有设备上出现的同样问题。 ","link":"https://Arron795.github.io/post/gnuGrubVersion2.02/"},{"title":"Qt安装工具MaintenanceTool安装插件出现无法下载存档的解决方法","content":"问题背景 在移植Qt项目时，代码中出现头文件QTextCodec无法找到的错误（QTextCodec是Qt5中的类，Qt6删除了该类），我使用的是Qt6版本，查阅解决方法，找到的方法要在Qt安装工具MaintenanceTool中添加组件Qt 5 Compatibility Module 遇到的问题 1、点击添加或移除组件都会出现提示： Your MaintenanceTool appears to be older than 3.0.2 Please update it first to get access to new Qt packages 2、添加组件，在下载的过程中出现： 无法下载存档 http://download.qt.io/online/gtsdkrepository/ windows x86/desktop/qt6 650 src doc examples/gt.gt6.650.doc/ 6.5.0-0-202303161324gt5-documentation.zip: Error transferring https://mirrors.aliyun.com/atproject/online/gtsdkrepository/ windows x86/desktop/qt6 650 src doc examples/gt.gt6.650.doc/ 6.5.0-0-202303161324qt5-documentation.zip - server replied: Not Found 解决方法 1、在MaintenanceTool页面点击右下角的设置 在网络选项下选择系统代理设置，HTTP代理填入的是中国科学技术大学的qt镜像源，并填入端口号8080 中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/ 当然也可以尝试其他qt镜像源：（本人未试过） 清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/ 北京理工大学：http://mirror.bit.edu.cn/qtproject/ 中国互联网络信息中心：http://mirror.bit.edu.cn/qtproject/ 特别提醒 本解决方案仅供参考，不保证所有遇到该问题的电脑都能解决，具体情况还需要具体分析。 ","link":"https://Arron795.github.io/post/qtMaintanceTool/"},{"title":"Keil 5下出现Error: L6218E: Undefined symbol Delay(unsigned) (referred from main.o).的解决方法","content":"问题背景： ​ 今天在给stm32f407vgt6点灯时，想实现循环闪烁，于是想从以前的工程中移植一个delay延时函数，移植后编译时发现出现错误： Error: L6218E: Undefined symbol Delay(unsigned) (referred from main.o).的解决方法 解决过程的思考: ​ 在确定了头文件Include路径的包含和.c文件的添加后，想起之前用C++实现STM32F103C8T6串口字符输出看过的一篇文章，文中提到一个工程中含有.cpp文件和.c文件混合实现时，在文件类型是C++的main.cpp下 所有用C语言实现的模块，添加.h时要加上 extern &quot;C&quot; { #include&quot;xxx.h&quot; //xxx代表文件名 ，根据实际修改 } 且文章的作者多次强调extern&quot;C&quot; 解决方法： ​ 原来包含的头文件如下，此处delay.c是用C语言实现，这种情况下会出现标题中的错误： 需要修改为如下： 再次编译，完美解决。 总结： ​ 在C++工程中想加入C语言实现的模块，在包含头文件时，需添加extern&quot;C&quot;{ xxx.h }。 ","link":"https://Arron795.github.io/post/keil5L6218E/"},{"title":"VS2022新建Qt项目出现“找不到 异常来自HERSULT:0x80030002“的解决方法","content":"问题描述： ​ Visual Studio 2022新建Qt Widgets Application 项目时出现 “找不到。异常来自HERSULT：80030002”。 解决方法： 打开VS，在顶栏找到 拓展 —&gt; 管理扩展 在已安装找到Qt VS Tools 点击卸载。（卸载完记得关闭所有VS窗口） 重启VS2022，还是点击扩展下的管理扩展 重新安装Qt VS Tools，安装完还是关闭所有VS窗口。 再次重启VS2022，新建Qt项目，顺利新建。 ","link":"https://Arron795.github.io/post/VS-qt-HERSULT/"},{"title":"基于STM32F103C8T6以USB to TTL 和 ST-LINK V2两种方式点亮LED小灯泡","content":"一、硬件设备 所需设备： 1、STM32F103C8T6； 2、USB 转 TLL 或 ST-LINK V2 01-0； 3、杜邦线若干； 4、面包板1个； 5、USB安卓数据线（使用USB 转 TLL需要用到）； 二、工程建立 1、首先需要建立一个STM32F103C8T6的keil工程。 ​ 可以根据以下链接结合实际情况建立： ​ (74条消息) STM32新建keil工程具体步骤（详细）_爱学习的小王呀的博客-CSDN博客 三、环境配置&amp;编写代码 1、环境配置 环境配置和代码可以参考以下两个链接： (74条消息) 用STM32F103C8T6制作流水灯_甜心猛男的博客-CSDN博客_c8t6烧程序时需要改变跳线帽位置吗 (74条消息) STM32F103寄存器方式点亮LED流水灯_Melody crush的博客-CSDN博客_stm32f103寄存器led点灯 这里简单给出几张个人认为需要注意的点： 先点击魔法棒 再点击Device 配置红框内容 ，并点击Debug（如果使用USB 转 TTL则不用勾选蓝色框；如果使用ST-link做的则要勾选） 点击上图蓝色框里的Setting，选择Flash Download，进行以下配置。（如果不选Reset and Run则每次烧录到板上后都需要按一下板上的Reset按键才会看到现象。选不选看个人，影响不大 2、编写main函数 //头文件 #include &quot;stm32f10x.h&quot; #include &quot;GPIOLIKE51.h&quot; //函数声明 void LED_Init(void); void RCC_Configuration(void); //============================================================================= //文件名称：Delay //功能概要：延时 //参数说明：nCount：延时长短 //函数返回：无 //============================================================================= void Delay(uint32_t nCount) { for(; nCount != 0; nCount--); } //============================================================================= //文件名称：main //功能概要：主函数 //参数说明：无 //函数返回：int //============================================================================= int main(void) { RCC_Configuration(); //开启GPIO时钟 LED_Init(); //初始LED引脚的GPIO口 while (1) { PAout(1)=0; //1为灭 Delay(0xfffff); //延时 Delay(0xfffff); Delay(0xfffff); Delay(0xfffff); Delay(0xfffff); PAout(1)=1; PBout(12)=0; //0为亮 Delay(0xfffff); Delay(0xfffff); Delay(0xfffff); Delay(0xfffff); Delay(0xfffff); PBout(12)=1; PCout(15)=0; Delay(0xfffff); Delay(0xfffff); Delay(0xfffff); Delay(0xfffff); Delay(0xfffff); PCout(15)=1; } } //============================================================================= //文件名称：RCC_Configuration //功能概要：开启GPIO时钟 //参数说明：无 //函数返回：无 //============================================================================= void RCC_Configuration(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //开启GPIOA时钟并使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //开启GPIOB时钟并使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); //开启GPIOC时钟并使能 } //============================================================================= //文件名称：LED_Init //功能概要：LED引脚的GPIO初始化 //参数说明：无 //函数返回：无 //============================================================================= void LED_Init(void) { GPIO_InitTypeDef GPIO_InitStruct; //声明GPIO初始化结构体,声明要在最前面 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //开启GPIOA时钟并使能 GPIO_InitStruct.GPIO_Pin = GPIO_Pin_1; //定义GPIO初始化结构体的GPIO引脚 GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; //定义GPIO初始化结构体的GPIO输出模式 GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; //定义GPIO初始化结构体的GPIO速率 GPIO_Init(GPIOA, &amp;GPIO_InitStruct); //初始化GPIO GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12; //定义GPIO初始化结构体的GPIO引脚 GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; //定义GPIO初始化结构体的GPIO输出模式，推挽输出模式 GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; //定义GPIO初始化结构体的GPIO速率 GPIO_Init(GPIOB, &amp;GPIO_InitStruct); //初始化GPIO GPIO_InitStruct.GPIO_Pin = GPIO_Pin_15; //定义GPIO初始化结构体的GPIO引脚 GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; //定义GPIO初始化结构体的GPIO输出模式，推挽输出模式 GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; //定义GPIO初始化结构体的GPIO速率 GPIO_Init(GPIOC, &amp;GPIO_InitStruct); //初始化GPIO } ​ 点击下面两个任意一个编译 确保0错误，0警告。 四、硬件连接 1、USB 转 TTL 方式 将STM32F103C8T6插入面包板，注意！一定要插深一点！确保C8T6的引脚能和面包板进行导电！！（笔者因为这个小细节没注意，排查了好几天的代码、硬件，甚至以为是笔者焊接不到位，重新把板的引脚焊过...最后排查出来是面包板和开发板的引脚接触不紧密没导上电...血的眼泪...） USB 转 TLL硬件插上电脑USB端口。 USB to TTL硬件和STM32F103C8T6连线。 跳线帽连接方式：*UBOOT0 用1；UBOOT1用0*。 ​ ​ USB转TTL连接方式：用杜邦线将USB to TTL的GND连开发板的GND、3.3V连3.3V、*RXD连接PA9*、*TXD连接PA10* 注意，下图此处有小红灯亮了，说明****RXD连接PA9****引脚连接可以导上电；如果是不亮的，则要检查一下是否会导电。 LED小灯连接方式：根据代码设定的GPIO端口，把LED小灯插到对应的引脚即可。笔者插的是A1、B12、C15引脚。注意！小灯泡会有高低脚，高的一侧要插正极，低的一侧插负极。 接地连接方式：用杜邦线把开发板上的G和面包板两侧的蓝色负极行连接起来。 最终连接效果： 打开设备管理器，确保有USB-SERIAL CH340（COMx）（如果没有显示或显示未知设备就去安装一个CH340的驱动） 打开FlyMCU，确保刚才端口是空闲状态（一般来讲，设备管理器识别的COM口号和FlyMCU的COM口号是一致的。这里解释一下为什么这里的COM口号和上面不同，因为笔者没有当时的截图，下面这张图时后来写博客时补的图...原来的端口电脑经常识别有误，所以插了另一个端口。） 进行以下配置，并点击三个小点...处，选择工程编译生成的.hex文件，点击开始编程。 别忘记按板上的Reset键，按了之后才会有反应。 ​ *常见问题： 未知USB设备（设备描述符请求失败） FlyMCU的Port端口显示占用 解决方法：右键卸载这个设备，再重新插拔USB 转 TTL，多试几次。笔者怀疑是USB转TLL和拓展坞的USB口接触不好导致的。 Fly MCU 出现无法打开串口 原因：说明电脑没有识别到USB转TTL的端口，请确保USB转TTL已经插上。如果确认插上，说明还是接触不好的问题。 解决方法：重新插拔USB 转 TTL，多试几次。（如果有条件，可以尝试更换一个TTL） 无法打开串口COMx:Not Support Setting(bps/byte size etc)! 原因：RXD连接PA9没有成功，需要检查一下PA9引脚是否导电，可以看USB转TTL上的小红灯有没有亮，没亮就是没导上电。 解决方法：1、更换TTL；2、更换杜邦线；3、插拔USB转TTL；4、重新焊接PA9引脚；5、如果之前烧录过其他程序，则尝试一下按Reset后再试一次。 2、ST-LINK V2 01-0方式 将STM32F103C8T6插入面包板，注意！一定要插深一点！确保C8T6的引脚能和面包板进行导电！！ ST-LINK V2仿真编程器插上电脑USB端口。 ST-LINK V2仿真编程器和STM32F103C8T6连线。 跳线帽连接方式：*UBOOT0 用0；UBOOT1用0*。 ST-LINK和电脑连接方式：（开发板上的DCLK就是ST-LINK上的CLK） LED小灯连接方式：根据代码设定的GPIO端口，把LED小灯插到对应的引脚即可。笔者插的是A1、B12、C15引脚。注意！小灯泡会有高低脚，高的一侧要插正极，低的一侧插负极。 ​ 接地连接方式：用杜邦线把开发板上的G和面包板两侧的蓝色负极行连接起来。 连接最终效果： 打开设备管理器，确保有STM32 STLink （如果没有显示或显示未知设备就去安装一个STLink的驱动） 打开Keil，在确认编译过、0错误，0警告后点击LOAD下载按钮。 显示下载成功信息。 如果在Debug的Setting勾选了Reset and Run则直接可以看到灯亮现象；如果没有勾选Reset and Run则需要再按一下开发板上的RESET按键才可以观察到灯亮现象。 五、实验效果 1、USB to TTL： 2、ST-LINK V2 ： 六、写在最后 ​ 感谢文中所引用博客的作者提供了思路和帮助，再次感谢。 ","link":"https://Arron795.github.io/post/lightTheLight/"},{"title":"关于在桥接模式下用VMware workstation运行Ubantu9.10无法上网的解决方法。","content":"1、打开控制面板。（不知道怎么打开的小朋友用左下角的搜索，直接搜控制面板） 2、打开网络和Internet。 3、点击网络和共享中心。 4、确认自己网络所用的名称（此处是以太网2），并点击。 5、点击属性。 6、找到本网络连接时所使用的网卡（不清楚为什么我这里显示的是声卡...，不过问题不大，记住这串名字就行。） 7、打开VMare Workstation所在文件夹，找到vmnetcfg.exe（这是一个虚拟网络配置器），点击打开。 8、点击右下角更改设置。 9、找到和刚刚一样的网卡，点击应用并确定。（注意：此处作者用网线接口上网，若是连接无线网络的电脑桥接请选择 Wi-Fi 6 那一个。） 10、 启动虚拟机 11、打开浏览器可以登录网页，测试IP地址，并尝试ping到主机的IP，成功ping通。 12、尝试主机ping虚拟机，成功ping通。 大功告成！ ","link":"https://Arron795.github.io/post/bridge/"},{"title":"通过安装VNC服务器x11vnc(或vnc4server)和配置x11vnc.service实现远程通过VNC-Viewer访问VNC服务器。","content":" Xshell的下载： 通过Xshell官网（链接：XShell - 下载 (softonic.com)）下载Xshell。 图 1 Xshell的下载 下载完成后安装，安装成功后打开Xshell： 图 2 Xshell 7界面 2.2 Ubuntu下x11vnc的安装和文件配置 1、步骤1： 在Ubantu18.04上查找虚拟机ip地址,并通过shell 7 连接。 图 3 Xshell 7输入用户名界面 图 4 Xshell 7使用虚拟机用户密码登录界面 图 5 Xshell 7连接虚拟机ip地址成功界面 2、步骤2：安装VNC相关软件包 sudo apt-get -y install x11vnc 图 6 在Xshell 7下连接虚拟机并安装x11vnc软件包 3、步骤3：安装lightdm图形界面软件包 sudo apt-get -y install lightdm 图7 安装lightdm软件包 选择lightdm并确定： 图 8 lightdm设定界面 4、步骤4：创建配置目录 mkdir -pv /home/syl4222/.vnc/ 图 9 配置目录 5、步骤5：设置用户的VNC connecting密码 x11vnc -storepasswd syl795 /home/syl4222/.vnc/passwd (红色部分为密码，黄色部分为用户名) 图 10 设置VNC连接密码 6、步骤6：在当前目录下生成vnc配置文件 cat&gt; x11vnc.service &lt;&lt;EOF [Unit] Description=Start x11vnc at startup. After=multi-user.target [Service] Type=simple ExecStart=/usr/bin/x11vnc -auth guess -once -loop -noxdamage -repeat -rfbauth -geometry 1024x768 /home/syl4222/.vnc/passwd -rfbport 5900 -shared [Install] WantedBy=multi-user.target EOF 图 11 在当前目录下生成vnc配置文件 7、步骤7： 剪切配置文件 sudo mv x11vnc.service /lib/systemd/system/x11vnc.service 修改权限为root sudo chown root:root /lib/systemd/system/x11vnc.service 重新加载服务配置文件 sudo systemctl daemon-reload 开机启动vnc服务 sudo systemctl enable x11vnc.service 图 12 （步骤7） 8、步骤8：重启操作系统 sudo reboot 图 13 重启界面（不知道为什么和原来的界面不一样） 2.3 Ubuntu下VNC-Viewer访问VNC服务器 1、步骤1：查看监听端口 sudo ss -tunlp 图 14 监听端口 2、步骤2：通过VNC viewr进行连接 输入IP地址和监听端口 图 15 通过VNC连接虚拟机 输入密码：（注意此处的密码是上文步骤5中设置的） 图 16 VNC认证 大功告成！ 图 17 实现在VNC Viewer上连接虚拟机 总结 1.用Xshell新建会话的时候，要根据虚拟机的IP地址来新建会话。 2.在Xshell输入的用户名必须是虚拟机的用户名，否则会出现密码报错。 3.若在Xshell界面ssh不通虚拟机的IP地址，应该考虑是否已经将虚拟机的网络设置为桥接网卡模式。 4.本次实践需要提前安装openssh-server软件包，若安装失败，可以考虑通过虚拟机上 显示应用程序 —&gt; 软件和更新—&gt; Ubuntu软件 —&gt; 下载自 —&gt; 选择其他站点 —&gt; 选择阿里云的服务器，并把上面的选项勾上，再重新尝试安装。（如下图） 图 18 软件和更新相关配置 ","link":"https://Arron795.github.io/post/x11vnc/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 本站点记录项目、问题、随笔、日常。 👨‍💻 博主是谁 小小Arron Sheh😎 ⛹ 兴趣爱好 看世界 📬 联系我呀 📞Tel : 13322674159 📫Email : 1970542332@qq.com ","link":"https://Arron795.github.io/post/about/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://Arron795.github.io/post/hello-gridea/"}]}